#### 1. 概述

比较运算符用于比较两个值的大小，然后返回一个布尔值，表示是否满足指定的条件。

> 注意，比较运算符可以比较各种类型的值，不仅仅是数值。

JS 一共提供了8个比较运算符

- `>` 大于运算符
- `<` 小于运算符
- `<=` 小于或等于运算符
- `>=` 大于或等于运算符
- `==` 相等运算符
- `===` 严格相等运算符
- `!=` 不相等运算符
- `!==` 严格不相等运算符

上述可分为两大类：相等和非相等比较。

非相等如果两边都是字符串，则按照字典顺序（Unicode码点）比较；否则均转为数值再进行比较

#### 2. 非相等运算符：字符串的比较

字符串按照字典顺序进行比较。

```js
'cat' > 'dog' // false
'cat' > 'catalog' // false
```

JavaScript 引擎内部**首先比较首字符的 Unicode 码点**（因此汉字也可以比较）。如果相等，再比较第二个字符的 Unicode 码点，以此类推。

#### 3. 非相等运算符：非字符串的比较

如果两个运算子之中，至少有一个不是字符串，需要分成以下两种情况。

###### （1）原始类型值

如果两个运算子都是原始类型的值，则是先转成数值再比较。

```js
5 > '4' // true
// 等同于 5 > Number('4')

true > false // true
// 等同于 Number(true) > Number(false)

2 > true // true
// 等同于 2 > Number(true)
```

这里需要注意与`NaN`的比较。任何值（包括`NaN`本身）与`NaN`比较，返回的都是`false`。

```js
0 < NaN // false
```

###### （2）对象

如果运算子是对象，会转为原始类型的值，再进行比较。

对象转换成原始类型的值，算法是先调用`valueOf`方法；如果返回的还是对象，再接着调用`toString`方法，详细解释参见《数据类型的转换》一章。

```js
var x = [2];
x > '11' // true
// 等同于 [2].valueOf().toString() > '11'
// 即 '2' > '11'

x.valueOf = function () { return '1' };
x > '11' // false
// 等同于 [2].valueOf() > '11'
// 即 '1' > '11'
```

#### 4. 严格相等运算符

类型不相同直接返回`false`

```js
undefined === null;
//false
```

类型相同的原始值，值相同即返回`true`（除了`NaN`），数字类型进制转换后相等返回`true`

复合类型比较它们是否指向同一个地址

```js
var obj1 = {};
var obj2 = {};
obj1 === obj2;
//false
```

#### 5. 严格不相等运算符

它的算法就是先将两边求严格相等运算，然后再返回相反值

#### 6. 相等运算符

比较同类型数据时候和 `===`相同，下面讨论不同类型值的时候转换

原始类型值比较：对非数值使用`Number`转换；

复合类型值比较：复合类型和数值/布尔值比较，对非数值使用`Number`；复合类型和字符串比较使用`String`

```js
[1] == 1 // true
// 等同于 Number([1]) == 1
[1] == '1' // true
// 等同于 String([1]) == '1'
[1] == true // true
// 等同于 Number([1]) == Number(true)
```

 `undefined`和`null`与其他类型的值比较时，结果都为`false`，它们互相比较时结果为`true` 

```js
undefined == null
```

由于相等运算带来的一些转换很容易出错，所以最好用严格相等 `===`

#### 7. 不相等运算符

它的算法就是先将两边求严格相等运算，然后再返回相反值