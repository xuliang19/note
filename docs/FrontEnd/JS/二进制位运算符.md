#### 1. 概述

二进制位运算符用于直接对二进制位进行计算，一共有7个。

- 二进制或运算符（or）：符号为`|`
- 二进制与运算符（and）：符号为`&`
- 二进制否运算符（not）：符号为`~`
- 异或运算符（xor）：符号为`^`
- 左移运算符（left shift）：符号为`<<`
- 右移运算符（right shift）：符号为`>>`
- 头部补零的右移运算符（zero filled right shift）：符号为`>>>`

 这些位运算符直接处理每一个比特位（bit），是非常底层的运算，好处是速度极快，缺点是很不直观（会使代码难以理解和除错）

!> 注：位运算只对整数起作用，如果不是整数，会转为整数再执行，做位运算时是以32位带符号的整数进行运算的，返回值也是一个32位带符号的整数

```js
function toInt32(x) {
  return x | 0;
}
```

上述代码可将`x`转为32位整数（会将大于32位的整位都舍去）

```js
toInt32(Math.pow(2, 32) + 1) // 1
toInt32(Math.pow(2, 32) - 1) // -1
```

#### 2. 二进制或运算符

二进制或运算符（`|`）逐位比较两个运算子，两个二进制位之中只要有一个为`1`，就返回`1`，否则返回`0` 

 位运算只对整数有效，遇到小数时，会将小数部分舍去，只保留整数部分。所以可用来取整（不适用超过32位整数最大值） `2147483647` 的数）

```js
2.9 | 0 // 2
```

#### 3. 二进制与运算符

二进制与运算符（`&`）的规则是逐位比较两个运算子，两个二进制位之中只要有一个位为`0`，就返回`0`，否则返回`1` 

```js
0 & 3 // 0
//相当于 00 & 11
```

#### 4. 二进制否运算符

二进制否运算符（`~`）将每个二进制位都变为相反值（`0`变为`1`，`1`变为`0`） 

```js
~ 3 // -4
```

`3`的32位整数形式是`00000000000000000000000000000011`，二进制否运算以后得到`11111111111111111111111111111100`。由于第一位（符号位）是1，所以这个数是一个负数。JavaScript 内部采用补码形式表示负数，即需要将这个数减去1，再取一次反，然后加上负号，才能得到这个负数对应的10进制值。这个数减去1等于`11111111111111111111111111111011`，再取一次反得到`00000000000000000000000000000100`，再加上负号就是`-4`。考虑到这样的过程比较麻烦，可以简单记忆成，**一个数与自身的取反值相加，等于-1** 

 对一个整数连续两次二进制否运算，得到它自身 ；所有位运算只对整数有效。利用这个可以达到取整的效果。

```js
~~2.9 // 2
```

使用二进制否运算取整，是所有取整方法中最快的一种。若运算子为字符串，会先使用`Number`函数，将字符串转为数值

```js
~"42 cats" // -1
```

#### 5. 异或运算符

异或运算（`^`）在两个二进制位不同时返回`1`，相同时返回`0`

异或运算有一个特殊作用，连续对`a`和`b`进行三次异或运算，可以互换他们的值， `a^=b; b^=a; a^=b;` 这样可以再不引入临时变量的情况下互换两个变量的值（互换变量值最快的方法）。异或还可以用来取整

```js
12.9 ^ 0 // 12
```

#### 6. 左移运算符

左移运算符（`<<`）表示将一个数的二进制值向左移动指定的位数，尾部补`0`，即**乘以`2`的指定次方**。向左移动的时候，最高位的符号位是一起移动的

```js
// 4 的二进制形式为100，
// 左移一位为1000（即十进制的8）
// 相当于乘以2的1次方
4 << 1
// 8

-4 << 1
// -8
```

上面代码中，`-4`左移一位得到`-8`，是因为`-4`的二进制形式是`11111111111111111111111111111100`，左移一位后得到`11111111111111111111111111111000`，该数转为十进制（减去1后取反，再加上负号）即为`-8`。

如果左移0位，就相当于将该数值转为32位整数，等同于取整，对于正数和负数都有效。

```js
13.5 << 0
// 13

-13.5 << 0
// -13
```

#### 7. 右移运算符

右移运算符（`>>`）表示将一个数的二进制值向右移动指定的位数。如果是正数，头部全部补`0`；如果是负数，头部全部补`1`。**右移运算符基本上相当于除以`2`的指定次方**（最高位即符号位参与移动） 8. 头部补零的右移运算符

```js
4 >> 1
//2
-4 >> 1
// -2
// 因为-4的二进制形式为 11111111111111111111111111111100，
// 右移一位，头部补1，得到 11111111111111111111111111111110,
// 即为十进制的-2
```

#### 8. 头部补零的右移运算符

与右移运算符差别是向右移动时，头部一律补零，而不考虑符号位。所以该运算总是得到正值。

当运算子为正数时，效果和`>>`一样，不同在于负数

```js
-4 >>> 1
// 2147483646
/*
// 因为-4的二进制形式为11111111111111111111111111111100，
// 带符号位的右移一位，得到01111111111111111111111111111110，
// 即为十进制的2147483646。
*/
```

这个运算实际上将一个值转为32位无符号整数。查看一个负整数在计算机内部的储存形式，最快的方法就是使用这个运算符

#### 9. 开关作用

位运算符可以用作设置对象属性的开关。

假定某个对象有四个开关，每个开关都是一个变量。那么，可以设置一个四位的二进制数，它的每个位对应一个开关。

```js
var FLAG_A = 1; // 0001
var FLAG_B = 2; // 0010
var FLAG_C = 4; // 0100
var FLAG_D = 8; // 1000
```

上面代码设置 A、B、C、D 四个开关，每个开关分别占有一个二进制位。

然后，就可以用二进制与运算检验，当前设置是否打开了指定开关。

```js
var flags = 5; // 二进制的0101

if (flags & FLAG_C) {
  // ...
}
// 0101 & 0100 => 0100 => true
```

上面代码检验是否打开了开关`C`。如果打开，会返回`true`，否则返回`false`。

现在假设需要打开`A`、`B`、`D`三个开关，我们可以构造一个掩码变量。

```js
var mask = FLAG_A | FLAG_B | FLAG_D;
// 0001 | 0010 | 1000 => 1011
```

上面代码对`A`、`B`、`D`三个变量进行二进制或运算，得到掩码值为二进制的`1011`。

有了掩码，二进制或运算可以确保打开指定的开关。

```js
flags = flags | mask;
```

二进制与运算可以将当前设置中凡是与开关设置不一样的项，全部关闭。

```js
flags = flags & mask;
```

异或运算可以切换（toggle）当前设置，即第一次执行可以得到当前设置的相反值，再执行一次又得到原来的值。

```js
flags = flags ^ mask;
```

二进制否运算可以翻转当前设置，即原设置为`0`，运算后变为`1`；原设置为`1`，运算后变为`0`。

```js
flags = ~flags;
```