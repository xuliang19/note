面向对象编程很重要的一方面就是对象的继承，A对象通过继承B对象，就能直接拥有B对象的所有属性和方法。这对代码的复用非常有用

大部分面向对象的编程语言，都是通过“类”（class）实现对象的继承。传统上，JavaScript 语言的继承不通过 class，而是通过“原型对象”（prototype）实现，本章介绍 JavaScript 的原型链继承。

ES6引入了class语法，详见《[ES6标准入门](http://es6.ruanyifeng.com/)》

#### 1. 原型对象概述

##### 1.1 构造函数的缺点

JavaScript 通过构造函数生成新对象，因此构造函数可以视为对象的模板。实例对象的属性和方法，可以定义在构造函数内部。

```js
function Cat (name, color) {
  this.name = name;
  this.color = color;
}
var cat1 = new Cat('大毛', '白色');
cat1.name // '大毛'
cat1.color // '白色'
```

通过构造函数为实例对象定义属性，虽然方便，但有一个缺点。同一个构造函数的多个实例之间无法共享属性，从而造成系统资源浪费

```js
function Cat(name, color) {
  this.name = name;
  this.color = color;
  this.meow = function () {
    console.log('喵喵');
  };
}
var cat1 = new Cat('大毛', '白色');
var cat2 = new Cat('二毛', '黑色');
cat1.meow === cat2.meow
// false
```

上面代码中，每新建一个实例，就会新建一个`meow`方法，没必要而且浪费资源。而`meow`方法都是同样的行为，应该共享使用。

解决这个问题就是用JS的原型对象（prototype）

##### 1.2 prototype 属性的作用

JS继承机制的设计思想就是，原型对象的所有属性和方法，都能被实例对象共享。

下面看如何为对象指定原型。JS规定每一个函数都有`prototype`属性，指向一个对象

```js
function f() {}
typeof f.prototype // "object"
```

对于普通函数来说，该属性基本无用。但对构造函数来说，生成实例的时候，该属性会自动成为实例对象的原型

```js
function Animal(name) {
  this.name = name;
}
Animal.prototype.color = 'white';
var cat1 = new Animal('大毛');
var cat2 = new Animal('二毛');
cat1.color // 'white'
cat2.color // 'white'
```



##### 1.3 原型链

##### 1.4 constructor 属性

#### 2. instanceof 运算符

#### 3. 构造函数的继承

#### 4. 多重继承

#### 5. 模块

##### 5.1 基本的实现方法

##### 5.2 封装私有变量：构造函数的写法

##### 5.3 封装私有变量：立即执行函数的写法

##### 5.4 模块的放大模式

##### 5.5 输入全局变量

